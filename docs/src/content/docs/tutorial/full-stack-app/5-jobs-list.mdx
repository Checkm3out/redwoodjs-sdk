---
title: Jobs List
slug: tutorial/full-stack-app/jobs-list
sidebar:
  label: Jobs List
description: A guide in my new Starlight docs site.
---

import { Aside, FileTree } from '@astrojs/starlight/components';

The jobs application list page lists all the jobs that we've applied for. For this tutorial, it will also serve as the Dashboard. ([In the Advanced Topics Tutorial, we'll iterate on the Dashboard]())

The finished page will look like this:

![](./images/figma-application-list.png)

Let's start with the backend code and then make it look good.

But, first, we need a page and a route.

In the `pages` directory, create a new folder called `applications`. Inside, create a file called `ListPage.tsx`.

<FileTree>
- src/
  - app/
    - pages/
      - applications/
        - ListPage.tsx
      - auth/
      - Home.tsx
</FileTree>

We can stub out a basic page, just to make sure it's loading correctly.

```tsx title="src/app/pages/applications/ListPage.tsx"
const ListPage = () => {
  return (
    <div>ListPage</div>
  )
}

export { ListPage }
```

Now, within our `worker.tsx` file, we can add a route for our new page.

```tsx title="src/worker.tsx" showLineNumbers=false
import { ListPage } from "./app/pages/applications/ListPage";
...
prefix("/applications", [
  route("/", ListPage),
])
---
- We'll group all of our application routes (List, New, Detail, Update) under the `/applications` prefix.
- When use visits `/applications`, they'll see our `ListPage` component.
---
```

Let's test this out in the browser. Go to `http://localhost:4321/applications` and you should see our stubbed out page.

![](./images/stubbed-out-applications-list-page.png)

Since we've already set up authentication, we can also protect this route.

```tsx
prefix("/applications", [
  route("/", [({ ctx }) => {
    if (!ctx.user) {
      return new Response(null, {
        status: 302,
        headers: { Location: "/user/login" },
      });
    }
  }, ListPage]),
])
```

This would get cumbersome (and annoying) if we have to do this for every.single.route we wanted to protect. Let's abstract this code into a reusable function.

```tsx
function isAuthenticated({ ctx }: { ctx: Context }) {
  if (!ctx.user) {
    return new Response(null, {
      status: 302,
      headers: { Location: "/user/login" },
    });
  }
}
```

Then, we can update our `/applications` route to use `isAuthenticated`:

```tsx
prefix("/applications", [
  route("/", [isAuthenticated, ListPage]),
])
```

Now, we can also update our home page route to use the `isAuthenticated` function, too:

```tsx
index([isAuthenticated, Home]),
```

Test it out. 👨‍🍳 Chef's kiss!

Now, let's get some data in the database that we can pull from.

[Earlier, I mentioned that sometimes I'll create multiple seed files with various purposes.](/tutorial/full-stack-app/database-setup#seed-the-database). This is a perfect opportunity to create a separate file just for adding job applications to our database.

Inside the `src/scripts` directory, create a new file called `applicationSeed.ts`.

Let's stub it out:

```tsx title="src/scripts/applicationSeed.ts"
import { defineScript } from "redwoodsdk/worker";
import { db, setupDb } from "../db";

export default defineScript(async ({ env }) => {
  setupDb(env);

  console.log("🌱 Finished seeding");
});
---
- **On line 4**, we're setting up the Cloudflare Worker environment to run our script. By default, we get the `env` object.
- **On line 5**, we're setting our database.
- **On line 7**, we're logging a message to the console to indicate that the script has finished running.
---
```

Inside our function, we can reach for a standard Prisma `create` function:

```tsx title="src/scripts/applicationSeed.ts" startLineNumber=7
const createApplication = async () => {
  await db.application.create({
    data: {
      salaryMin: "100000",
      salaryMax: "120000",
      jobTitle: "Software Engineer",
      jobDescription: "Software Engineer",
      postingUrl: "https://redwoodjs.com",
      dateApplied: new Date(),
    }
  }
};
---
- **On line 8,** we're referencing the `application` table. Then, using the Prisma `create` function to add all the data in our database object. You'll notice that these values match the columns we defined in `Prisma.schema` file.
---
```

If you run the script now, you'll hit a few errors because it's also looking for related `user`, `status`, and `company` entries. For the `user` and `status` connections, we already have entries within the database we can use.

![](./images/user-id-in-database.png)

;tk

```tsx
export default defineScript(async ({ env }) => {
  setupDb(env);

  await db.application.create({
    data: {
      user: {
        connect: {
          id: "0f9a097c-d7bc-4ab5-8b11-6942163df348",
        },
      },
      status: {
        connect: {
          id: 1,
        },
      },
      salaryMin: "100000",
      salaryMax: "120000",
      jobTitle: "Software Engineer",
      jobDescription: "Software Engineer",
      postingUrl: "https://redwoodjs.com",
      dateApplied: new Date(),
      company: {
        create: {
          name: "RedwoodSDK",
          contacts: {
            create: {
              firstName: "John",
              lastName: "Doe",
              email: "john.doe@example.com",
              role: "Hiring Manager",
            },
          },
        },
      },
    },
  });

  console.log("🌱 Finished seeding");
});
```

On the Applications list page:

```tsx title="src/app/pages/applications/ListPage.tsx"
import { db } from "src/db";

const ListPage = async () => {
  const applications = await db.application.findMany();

  return (
    <div>
      {JSON.stringify(applications)}
    </div>
  )
}

export { ListPage }
```

Now that we know the content from our database is getting on the page, let's style it.

## Styling the Job Applications List Page

### Creating an Interior Page Layout

```tsx
import { Header } from "app/components/Header";

const InteriorLayout = ({ children }: { children: React.ReactNode}) => {
  return (
    <div className="page-wrapper">
      <main className="bg-white rounded-xl border-2 border-[#D6D5C5]">
        <Header />
        <div>{children}</div>
      </main>
    </div>
  )
}

export { InteriorLayout }
```

### Creating the Header Component

```tsx
import React from 'react'
import logo from "app/assets/logo.svg"
import { Avatar, AvatarImage, AvatarFallback } from 'app/components/ui/avatar'
import { link } from 'app/shared/links'

const Header = () => {
  return (
    <header className="py-5 px-page-side h-20 flex justify-between items-center border-b-1 border-border mb-12">
      {/* left side */}
      <div className="flex items-center gap-8">
        <div className="">
          <a href={link("/")} className="flex gap-3 font-display font-bold text-3xl items-center">
            <img src={logo} alt="Apply Wize" className="inline-block pt-5 -mb-3" />
            <span>Apply Wize</span>
          </a>
        </div>
        <nav>
          <ul>
            <li><a href={link("/applications")}>Dashboard</a></li>
          </ul>
        </nav>
      </div>

      {/* right side */}
      <nav>
        <ul className="flex items-center gap-7">
          <li><a href={link("/account/settings")}>Settings</a></li>
          <li><a href={link("/logout")}>Logout</a></li>
        </ul>
      </nav>
    </header>
  )
}

export { Header }
```




### Styling the Applications Table

```tsx
import React from 'react'
import { link } from "app/shared/links";
import { Badge } from "app/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "app/components/ui/avatar";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "app/components/ui/table"
import { Icon } from "app/components/Icon";
import { Application } from "@prisma/client";

interface ApplicationsTableProps {
  applications: Application[]
}

const ApplicationsTable = ({ applications }: ApplicationsTableProps) => {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-[100px]">Status</TableHead>
          <TableHead>Date Applied</TableHead>
          <TableHead>Job Title</TableHead>
          <TableHead>Company</TableHead>
          <TableHead>Contact</TableHead>
          <TableHead>Salary Range</TableHead>
          <TableHead></TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {applications.map((application) => (
          <TableRow key={application.id}>
            <TableCell><Badge variant={application.status.status.toLowerCase()}>{application.status.status}</Badge></TableCell>
            <TableCell>{application.dateApplied.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            })}</TableCell>
            <TableCell>{application.jobTitle}</TableCell>
            <TableCell>{application.company.name}</TableCell>
            <TableCell className="flex gap-2 items-center">
              {application.company?.contacts && application.company?.contacts?.length > 0 && (
                <>
                  {/* <Avatar>
                    <AvatarImage src="https://github.com/shadcn.png" alt="@shadcn" />
                    <AvatarFallback>CN</AvatarFallback>
                  </Avatar> */}
                  {application.company.contacts[0].firstName} {application.company.contacts[0].lastName}
                </>
              )}
            </TableCell>
            <TableCell>${application.salaryMin}-${application.salaryMax}</TableCell>
            <TableCell><a href={link("/applications/:id", { id: application.id })}><Icon id="eye" /></a></TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}

export {  ApplicationsTable }
```





- Creating the main jobs page layout
- Building and styling the jobs table using ShadCN Table component
- Adding the "Create New Job" button with ShadCN Button component

<Aside type="tip" title="Code on GitHub">
You can find the final code for this step on [GitHub](https://github.com/redwoodjs/applywize).
</Aside>

## Further reading

- Read [about how-to guides](https://diataxis.fr/how-to-guides/) in the Diátaxis framework
